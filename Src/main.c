/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define USE_FULL_LL_DRIVER

#include "main.h"

static volatile uint32_t tick = 0;
static void delay_ms(uint32_t ms);

static volatile uint8_t tx_busy = 0;


//uint16_t CRC16_CCITT(const uint8_t *data, uint16_t length);




DataFrame_t frame;
uint8_t id;
struct bme280_dev v_bme280_dev;
struct bme280_uncomp_data v_uncomp_data;
struct bme280_data v_bme280_data;
uint8_t calib_data1[26];
uint8_t calib_data2[7];

int main(void) {


	 SystemClock_Config();
	 GPIO_Config();
     USART1_Config();
     I2C1_Config();
     DMA_Config();

	__enable_irq();

	uint8_t ctrl_hum  = 0x05;  // osrs_h = x16
	uint8_t ctrl_meas = 0xB7;  // osrs_t = x16, osrs_p = x16, mode = normal    0b101_101_11
	uint8_t config    = 0x10;  // filter x16, standby 0.5ms

	i2c_reg_write(g_i2c, 0x76, 0xF5, &config, 1);
	i2c_reg_write(g_i2c, 0x76, 0xF2, &ctrl_hum, 1);
	i2c_reg_write(g_i2c, 0x76, 0xF4, &ctrl_meas, 1);

	i2c_reg_read( g_i2c, 0x76, 0xD0, &id, 1);

	i2c_reg_read(g_i2c, 0x76, 0x88, calib_data1, 26);
	i2c_reg_read(g_i2c, 0x76, 0xE1, calib_data2, 7);

	parse_temp_press_calib_data(calib_data1, &v_bme280_dev);
	parse_humidity_calib_data(calib_data2, &v_bme280_dev);

	while (1) {

		uint8_t raw[8];
		i2c_reg_read(g_i2c, 0x76, 0xF7, raw, 8);

		parse_sensor_data(raw, &v_uncomp_data);

		bme280_compensate_data(0x07, &v_uncomp_data, &v_bme280_data, &v_bme280_dev.calib_data);



	    /*  (×10, zaokrąglenie) */
	    double tC = v_bme280_data.temperature;
	    int32_t t10 = (int32_t)(tC * 10.0 + (tC >= 0 ? 0.5 : -0.5));
	    if (t10 > INT16_MAX) t10 = INT16_MAX;
	    if (t10 < INT16_MIN) t10 = INT16_MIN;


	    double pPa = v_bme280_data.pressure;
	    int32_t p_hPa = (int32_t)((pPa + 50.0) / 100.0);   // +50 dla zaokrąglenia
	    if (p_hPa < 0) p_hPa = 0;
	    if (p_hPa > 0xFFFF) p_hPa = 0xFFFF;


	    double h = v_bme280_data.humidity;
	    int32_t h_pct = (int32_t)(h + 0.5);
	    if (h_pct < 0) h_pct = 0;
	    if (h_pct > 100) h_pct = 100;


	    frame.sof       = 0xAA55;
	    frame.timestamp = tick;
	    frame.temp      = (int16_t)t10;
	    frame.press     = (uint16_t)p_hPa;
	    frame.hum       = (uint16_t)h_pct;

	    frame.crc = CRC16_CCITT((uint8_t*)&frame, sizeof(DataFrame_t) - sizeof(frame.crc));

		if (!tx_busy) {
			tx_busy = 1;
			LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
			LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_4, (uint32_t) &frame);
			LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_4, sizeof(frame));
			LL_DMA_ClearFlag_GI4(DMA1); //
			LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_4); //
		}

		delay_ms(5000);

	}
////////////////////////////////////////////////////
}

void DMA1_Channel4_IRQHandler(void) {
	if (LL_DMA_IsActiveFlag_TC4(DMA1)) {
		LL_DMA_ClearFlag_TC4(DMA1);
		LL_DMA_ClearFlag_HT4(DMA1);
		//LL_DMA_ClearFlag_GI4(DMA1);
		LL_DMA_DisableChannel(DMA1, LL_DMA_CHANNEL_4);
		tx_busy = 0;
		LL_GPIO_TogglePin(GPIOA, LL_GPIO_PIN_5);
	}
}

void SysTick_Handler(void) {
	tick++;
}

static void delay_ms(uint32_t ms) {
	uint32_t start = tick;
	while ((tick - start) < ms) { /* busy wait */
	}
}



